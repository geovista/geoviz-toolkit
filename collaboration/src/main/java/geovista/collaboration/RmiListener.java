/* Licensed under LGPL v. 2.1 or any later version;
 see GNU LGPL for details.
 Original Authors: Frank Hardisty and Linna Li */

package geovista.collaboration;

import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.net.InetAddress;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.Preferences;

import javax.swing.JPanel;

// note: there is an RmiListener_Stub class that is generated by the
// rmic command line option. This class will need to be recompiled
// if the api (class signature) of this class changes.
public class RmiListener extends UnicastRemoteObject implements
		RemoteMessageReceiver, RemoteSelectionListener,
		RemoteSpatialExtentListener, RemoteSubspaceListener {
	int thisPort;
	String thisAddress;
	Registry registry; // rmi registry for lookup the remote objects.
	RmiListenerClient client; // object who is listening to us. probably
	// a RemoteCollaboration on the local jvm

	protected final static Logger logger = Logger.getLogger(RmiListener.class
			.getName());
	JPanel pan = new JPanel();
	private static boolean startedSystemRegistry;
	private static boolean boundObjectToRegistry;

	public RmiListener(int port) throws RemoteException {

		try {
			// get the address of the local host.
			thisAddress = (InetAddress.getLocalHost()).toString();
		} catch (Exception e) {
			throw new RemoteException("can't get inet address.");
		}
		thisPort = port; // this port(registry’s port)
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("this address=" + thisAddress + ",port=" + thisPort);
		}
		try {
			// create or find the registry
			if (!RmiListener.boundObjectToRegistry) {
				if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
					logger
							.finest("registry already started, will not bind RmiListener class");
				}
				// create registry
				registry = LocateRegistry.createRegistry(thisPort);
			} else {
				if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
					logger
							.finest("registry already started, looking up registry");
				}
				// find registry
				registry = LocateRegistry.getRegistry(thisPort);
			}
			// bind our class name and a reference to "this" to the registry
			registry.rebind(RmiListener.class.getName(), this);

		} catch (RemoteException e) {
			e.printStackTrace();
		}
		// RmiListener.boundClass = true;
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("bound class to rmi registry");
		}
	}

	public static Object connectToRemoteJVM(String ip) {

		Preferences gvPrefs = Preferences
				.userNodeForPackage(RemoteCollaboration.class);
		gvPrefs.put("LastGoodIP", ip);

		Registry registry;
		String listenerAddress = ip;
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("connecting to " + listenerAddress + ":"
					+ RemoteCollaboration.DEFAULT_PORT);
		}
		Object obj = null;
		// RmiListener rListener = null;
		try {
			// get the remote registry
			registry = LocateRegistry.getRegistry(listenerAddress,
					RemoteCollaboration.DEFAULT_PORT);
			// look up the remote object
			obj = registry.lookup(RmiListener.class.getName());
			if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
				logger.finest("Remote obj.getClass().getName() = "
						+ obj.getClass().getName());
			}
			// rListener =(RmiListener) obj;

		} catch (RemoteException e) {
			e.printStackTrace();
		} catch (NotBoundException e) {
			e.printStackTrace();
		}
		return obj;
	}

	public static void startRegistry() {
		if (RmiListener.startedSystemRegistry) {
			if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
				logger
						.finest("system java rmi registry already started, will not restart");
			}

			return;
		}
		RmiListener.startedSystemRegistry = true;
		try {
			if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
				logger.finest("starting registry....");
			}

			Runtime.getRuntime().exec("rmiregistry"); // start the rmi
			// registry on the local
			// machine. The registry exists outside this jvm.
			// There needs to be a pause of a second or so after this local
			// command is called, before
			// any objects register themselves with it. In this class, the pause
			// is supplied by
			// a wait thread in the constructor of the calling class.

			// Runtime.getRuntime().exec("rmic -d .
			// geovista.collaboration.RmiListener");
			// Runtime.getRuntime().exec("rmic -d .
			// geovista.collaboration.RemoteCollaboration");
			// System.setSecurityManager();
		} catch (IOException ex) {
			ex.printStackTrace();
		}
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("system java rmi registry started.");
		}

	}

	public void extentChanged(String source, double[] extent)
			throws RemoteException {

		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("RmiListener, got spatialExtent");
		}
		// (x,y,w,h)
		Rectangle2D.Double extentRect = new Rectangle2D.Double(extent[0],
				extent[1], extent[2], extent[3]);
		client.remoteSpatialExtentChanged(source, extentRect);
	}

	// This method is called from the remote client by the RMI.
	// This is the implementation of the “ReceiveMsgInterface”.
	public void receiveMessage(String name, String msg) throws RemoteException {
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("RmiListener, receivedMessage from rmi" + msg);
		}
		client.remoteMessageReceived(name, msg);
	}

	public void selectionChanged(String source, int[] selection)
			throws RemoteException {
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("RmiListener, got selection");
		}
		// we got this selection from somewhere (maybe another JVM)
		// send it along to registered listeners in this JVM
		client.remoteSelectionChanged(source, selection);
	}

	public void subspaceChanged(String source, int[] subspace)
			throws RemoteException {
		if (RemoteCollaboration.logger.isLoggable(Level.FINEST)) {
			logger.finest("RmiListener, got selection");
		}
		// we got this selection from somewhere (maybe another JVM)
		// send it along to registered listeners in this JVM
		client.remoteSubspaceChanged(source, subspace);
	}

	static public void main(String args[]) {
		try {
			RmiListener s = new RmiListener(RemoteCollaboration.DEFAULT_PORT);
			logger.finest("rmi listener " + s);
		} catch (Exception e) {
			e.printStackTrace();

		}
	}

	public void setClient(RmiListenerClient client) {
		this.client = client;
	}
}
